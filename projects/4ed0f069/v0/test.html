<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子シミュレーター テスト</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #0f0f1e;
            color: #e0e0e0;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #1a1a2e;
            border: 1px solid #2a2a3e;
            border-radius: 8px;
        }
        .pass { color: #06ffa5; }
        .fail { color: #ff4444; }
        h2 { color: #00d4ff; }
        pre {
            background: #252538;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>

    
    <!-- Open Graph / OGP - Auto-generated by Bot -->
    <meta property="og:title" content="「AI機能の修正とテストの実施」">
    <meta property="og:description" content="「AI機能の修正とテストの実施」">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://vps.nekodigi.com/ccbot/projects/4ed0f069">
    <meta property="og:image" content="None">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">

    <!-- Twitter Card - Auto-generated by Bot -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="「AI機能の修正とテストの実施」">
    <meta name="twitter:description" content="「AI機能の修正とテストの実施」">
    <meta name="twitter:image" content="None">
  </head>
<body>
    <h1>量子コンピュータシミュレーター テストスイート</h1>
    <div id="test-results"></div>

    <script type="module">
        import { QuantumSimulator } from './quantum-simulator.js';

        const results = document.getElementById('test-results');

        function addResult(title, passed, details) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `
                <h2>${passed ? '✓' : '✗'} ${title}</h2>
                <p class="${passed ? 'pass' : 'fail'}">${passed ? 'PASS' : 'FAIL'}</p>
                <pre>${details}</pre>
            `;
            results.appendChild(section);
        }

        // テスト1: 初期化
        try {
            const sim = new QuantumSimulator(1);
            const state = sim.stateVector;
            const passed = Math.abs(state[0].real - 1) < 0.001 && Math.abs(state[0].imag) < 0.001;
            addResult(
                'Test 1: 初期化テスト',
                passed,
                `初期状態: ${sim.getStateString()}\n期待値: |0⟩状態 (1.000+0.000i)`
            );
        } catch (e) {
            addResult('Test 1: 初期化テスト', false, e.message);
        }

        // テスト2: Hadamardゲート
        try {
            const sim = new QuantumSimulator(1);
            sim.hadamard(0);
            const state = sim.stateVector;
            const expected = 1 / Math.sqrt(2);
            const passed = Math.abs(state[0].real - expected) < 0.001 &&
                          Math.abs(state[1].real - expected) < 0.001;
            addResult(
                'Test 2: Hadamardゲート',
                passed,
                `結果: ${sim.getStateString()}\n期待値: 重ね合わせ状態 (0.707+0.000i |0⟩ + 0.707+0.000i |1⟩)`
            );
        } catch (e) {
            addResult('Test 2: Hadamardゲート', false, e.message);
        }

        // テスト3: パウリXゲート (NOT)
        try {
            const sim = new QuantumSimulator(1);
            sim.pauliX(0);
            const state = sim.stateVector;
            const passed = Math.abs(state[1].real - 1) < 0.001;
            addResult(
                'Test 3: パウリXゲート (NOT)',
                passed,
                `結果: ${sim.getStateString()}\n期待値: |1⟩状態`
            );
        } catch (e) {
            addResult('Test 3: パウリXゲート (NOT)', false, e.message);
        }

        // テスト4: 回転ゲート
        try {
            const sim = new QuantumSimulator(1);
            sim.rotationY(0, Math.PI / 2);
            const state = sim.stateVector;
            const expected = 1 / Math.sqrt(2);
            const passed = Math.abs(Math.abs(state[0].real) - expected) < 0.1;
            addResult(
                'Test 4: Y軸回転ゲート (π/2)',
                passed,
                `結果: ${sim.getStateString()}\n回転角度: π/2`
            );
        } catch (e) {
            addResult('Test 4: Y軸回転ゲート', false, e.message);
        }

        // テスト5: 複数量子ビット
        try {
            const sim = new QuantumSimulator(2);
            sim.hadamard(0);
            const state = sim.stateVector;
            const passed = sim.stateVector.length === 4;
            addResult(
                'Test 5: 複数量子ビット (2 qubits)',
                passed,
                `結果: ${sim.getStateString()}\n状態ベクトルサイズ: ${sim.stateVector.length} (期待値: 4)`
            );
        } catch (e) {
            addResult('Test 5: 複数量子ビット', false, e.message);
        }

        // テスト6: CNOTゲート
        try {
            const sim = new QuantumSimulator(2);
            sim.hadamard(0);
            sim.cnot(0, 1);
            const probs = sim.getMeasurementProbabilities();
            // Bell状態: |00⟩と|11⟩のみに確率が集中
            const bellState = Math.abs(probs[0] - 0.5) < 0.1 && Math.abs(probs[3] - 0.5) < 0.1;
            addResult(
                'Test 6: CNOTゲート (Bell状態生成)',
                bellState,
                `結果: ${sim.getStateString()}\n|00⟩確率: ${(probs[0]*100).toFixed(1)}%\n|11⟩確率: ${(probs[3]*100).toFixed(1)}%`
            );
        } catch (e) {
            addResult('Test 6: CNOTゲート', false, e.message);
        }

        // テスト7: 測定
        try {
            const sim = new QuantumSimulator(1);
            sim.pauliX(0);
            const result = sim.measure();
            const passed = result === 1;
            addResult(
                'Test 7: 測定 (|1⟩状態)',
                passed,
                `測定結果: ${result}\n期待値: 1 (|1⟩状態は常に1を測定)`
            );
        } catch (e) {
            addResult('Test 7: 測定', false, e.message);
        }

        // テスト8: ブロッホ球座標
        try {
            const sim = new QuantumSimulator(1);
            sim.hadamard(0);
            const blochState = sim.getSingleQubitState();
            const passed = Math.abs(blochState.x - 1) < 0.1 && Math.abs(blochState.z) < 0.1;
            addResult(
                'Test 8: ブロッホ球座標計算',
                passed,
                `ブロッホ座標: (x=${blochState.x.toFixed(3)}, y=${blochState.y.toFixed(3)}, z=${blochState.z.toFixed(3)})\nHadamard適用後は+X方向を向く`
            );
        } catch (e) {
            addResult('Test 8: ブロッホ球座標', false, e.message);
        }

        // テスト9: 回路の記録
        try {
            const sim = new QuantumSimulator(1);
            sim.hadamard(0);
            sim.pauliZ(0);
            sim.hadamard(0);
            const passed = sim.circuit.length === 3;
            addResult(
                'Test 9: 量子回路の記録',
                passed,
                `記録されたゲート数: ${sim.circuit.length}\n回路: ${sim.circuit.map(g => g.gate).join(' → ')}`
            );
        } catch (e) {
            addResult('Test 9: 量子回路の記録', false, e.message);
        }

        // テスト10: リセット機能
        try {
            const sim = new QuantumSimulator(1);
            sim.hadamard(0);
            sim.reset();
            const passed = sim.circuit.length === 0 && Math.abs(sim.stateVector[0].real - 1) < 0.001;
            addResult(
                'Test 10: リセット機能',
                passed,
                `リセット後の状態: ${sim.getStateString()}\nリセット後の回路長: ${sim.circuit.length}`
            );
        } catch (e) {
            addResult('Test 10: リセット機能', false, e.message);
        }

        // 統計情報
        setTimeout(() => {
            const sections = document.querySelectorAll('.test-section');
            let passed = 0;
            let failed = 0;
            sections.forEach(section => {
                if (section.textContent.includes('PASS')) passed++;
                else failed++;
            });

            const summary = document.createElement('div');
            summary.className = 'test-section';
            summary.innerHTML = `
                <h2>テスト結果サマリー</h2>
                <p class="pass">成功: ${passed}件</p>
                <p class="${failed > 0 ? 'fail' : 'pass'}">失敗: ${failed}件</p>
                <p>合計: ${passed + failed}件</p>
            `;
            results.insertBefore(summary, results.firstChild);
        }, 100);
    </script>
</body>
</html>
